'use strict';
// better-sqlite3의 트랜잭션 래퍼 구현부
// 이 모듈은 사용자가 전달한 함수(fn)를 BEGIN/COMMIT/ROLLBACK(또는 SAVEPOINT/RELEASE)으로 감싸서
// 오류 시 자동 롤백, 정상 시 커밋이 되도록 "트랜잭션 함수"를 생성합니다.
const { cppdb } = require('../util');
const controllers = new WeakMap();

module.exports = function transaction(fn) {
	// 사용법: db.transaction(fn)
	// - fn: 트랜잭션 내에서 실행할 사용자 함수(동기 함수)
	if (typeof fn !== 'function') throw new TypeError('Expected first argument to be a function');

	const db = this[cppdb];
	// 동일 DB 인스턴스에 대해 BEGIN/COMMIT/SAVEPOINT 등 준비된 스테이트먼트를 캐시해서 재사용
	const controller = getController(db, this);
	const { apply } = Function.prototype;

	// Each version of the transaction function has these same properties
	// 트랜잭션 격리/시작 모드별 버전들(default/deferred/immediate/exclusive)을 동시에 만들어 둡니다.
	// - default: BEGIN
	// - deferred: BEGIN DEFERRED
	// - immediate: BEGIN IMMEDIATE
	// - exclusive: BEGIN EXCLUSIVE
	const properties = {
		default: { value: wrapTransaction(apply, fn, db, controller.default) },
		deferred: { value: wrapTransaction(apply, fn, db, controller.deferred) },
		immediate: { value: wrapTransaction(apply, fn, db, controller.immediate) },
		exclusive: { value: wrapTransaction(apply, fn, db, controller.exclusive) },
		database: { value: this, enumerable: true },
	};

	// 반환되는 함수에도 위의 모든 버전을 동일 프로퍼티로 달아
	// .deferred/.immediate/.exclusive로 모드를 바꿔 호출할 수 있게 합니다.
	Object.defineProperties(properties.default.value, properties);
	Object.defineProperties(properties.deferred.value, properties);
	Object.defineProperties(properties.immediate.value, properties);
	Object.defineProperties(properties.exclusive.value, properties);

	// Return the default version of the transaction function
	// 기본값은 BEGIN (default) 모드의 트랜잭션 함수
	return properties.default.value;
};

// Return the database's cached transaction controller, or create a new one
// DB별로 트랜잭션에서 사용할 스테이트먼트를 준비해 두고 재사용합니다.
// shared: COMMIT/ROLLBACK/SAVEPOINT/RELEASE/ROLLBACK TO
// 각 모드: BEGIN / BEGIN DEFERRED / BEGIN IMMEDIATE / BEGIN EXCLUSIVE
const getController = (db, self) => {
	let controller = controllers.get(db);
	if (!controller) {
		const shared = {
			commit: db.prepare('COMMIT', self, false),
			rollback: db.prepare('ROLLBACK', self, false),
			savepoint: db.prepare('SAVEPOINT `\t_bs3.\t`', self, false),
			release: db.prepare('RELEASE `\t_bs3.\t`', self, false),
			rollbackTo: db.prepare('ROLLBACK TO `\t_bs3.\t`', self, false),
		};
		controllers.set(db, controller = {
			default: Object.assign({ begin: db.prepare('BEGIN', self, false) }, shared),
			deferred: Object.assign({ begin: db.prepare('BEGIN DEFERRED', self, false) }, shared),
			immediate: Object.assign({ begin: db.prepare('BEGIN IMMEDIATE', self, false) }, shared),
			exclusive: Object.assign({ begin: db.prepare('BEGIN EXCLUSIVE', self, false) }, shared),
		});
	}
	return controller;
};

// Return a new transaction function by wrapping the given function
// wrapTransaction은 전달된 fn을 실제 트랜잭션 경계로 감쌉니다.
// - 이미 트랜잭션 안이면 SAVEPOINT/RELEASE/ROLLBACK TO를 사용(중첩 트랜잭션 흉내)
// - 트랜잭션 밖이면 BEGIN/COMMIT/ROLLBACK을 사용(새 트랜잭션 시작)
const wrapTransaction = (apply, fn, db, { begin, commit, rollback, savepoint, release, rollbackTo }) => function sqliteTransaction() {
	let before, after, undo;
	if (db.inTransaction) {
		// 중첩 호출: SAVEPOINT로 묶고, 실패 시 해당 세이브포인트로 롤백
		before = savepoint;
		after = release;
		undo = rollbackTo;
	} else {
		// 최상위 호출: BEGIN으로 시작하고, 실패 시 전체 ROLLBACK/성공 시 COMMIT
		before = begin;
		after = commit;
		undo = rollback;
	}
	before.run();
	try {
		// 사용자가 넘긴 함수 실행
		// apply.call(fn, this, arguments): 원본 컨텍스트/인자 유지하여 호출
		const result = apply.call(fn, this, arguments);
		after.run();
		return result;
	} catch (ex) {
		if (db.inTransaction) {
			// 세이브포인트 사용 중이라면 해당 지점으로 롤백하고,
			// 세이브포인트를 썼다면 RELEASE(정상 종료)도 호출해 균형을 맞춤
			undo.run();
			if (undo !== rollback) after.run();
		}
		throw ex;
	}
};
